#!/system/bin/sh
set -eux

# API 26 (Android 8.0) doesn't have readlink -f, so we use a more compatible approach
script_path="$0"
# Try readlink -f first (API 29+), fall back to just using $0
if command -v readlink >/dev/null 2>&1; then
  script_path="$(readlink -f "$0" 2>/dev/null || echo "$0")"
fi
script_dir="$(cd "$(dirname "$script_path")" && pwd)"
stoic_device_sync_dir="$(cd "$script_dir/.." && pwd)"
cd "$script_dir"

run_as_compat() {
  case "$attach_option" in
    jvmti)
      run-as "$@"
      ;;
    jvmti_root)
      "$script_dir/su-run-as" "$@"
      ;;
    sdk)
      run-as "$@"
      ;;
    *)
      >&2 echo "Invalid attach option '$attach_option'"
      exit 1
      ;;
  esac
}

attach_agent_compat() {
  case "$attach_option" in
    jvmti)
      am attach-agent "$@"
      ;;
    jvmti_root)
      su 0 am attach-agent "$@"
      ;;
    *)
      >&2 echo "Invalid attach option '$attach_option'"
      exit 1
      ;;
  esac
}

monkey_package() {
  monkey --pct-syskeys 0 -p "$pkg" 1 >/dev/null || true 2>&1
}

start_package() {
  monkey_package
  for i in $(seq 1 5); do
    for j in $(seq 1 500); do
      if pkg_pid="$(pidof "$pkg")"; then
        return 0
      fi
    done
    >&2 "$pkg is slow to start (maybe it's stuck) - retrying monkey"
    monkey_package
  done

  >&2 "Failed to start $pkg"
  return 1
}

resolve_package_pid() {
  case "$start_option" in
    restart)
      am force-stop "$pkg"
      start_package
      ;;
    do_not_start)
      pkg_pid="$(pidof "$pkg")"
      ;;
    start_if_needed)
      if ! pkg_pid="$(pidof "$pkg")"; then
        start_package
      fi
      ;;
    *)
      echo "Invalid start option: '$start_option'" >&2
      return 1
      ;;
  esac
}

cross_uid_cp() {
  perms="$1"
  src="$2"
  dst="$3"
  cat "$src" | run_as_compat "$pkg" sh -c "cat > $dst && chmod $perms $dst"
}

target_process_exited=0
logcat_pid=""
selinux_denials_pgid_file=""
cleanup_attach() {
  if [ -n "${logcat_pid:-}" ]; then
    if [ "$target_process_exited" = "1" ]; then
      # We want to make sure we print all the information we need to debug why
      # the target process exited, so we give the logcat process a chance to
      # finish piping everything before we kill it
      sleep 1
    fi

    kill "$logcat_pid" || true
  fi
  if [ -n "${selinux_denials_pgid_file:-}" ]; then
    run_as_compat "$pkg" sh -c "kill -TERM -\$(cat $selinux_denials_pgid_file)" || true
  fi
  >&2 echo "Finished cleanup_attach\n$attach_error_summary"
}

attach_jvmti() {
  trap cleanup_attach EXIT

  pkg_dir="$(run_as_compat "$pkg" printenv HOME)"
  pkg_stoic_dir="$pkg_dir/stoic"
  pkg_so="$pkg_stoic_dir/stoic-jvmti-agent.so"
  pkg_server_apk="$pkg_stoic_dir/stoic-jvmti-attach.apk"
  pkg_options_json="$pkg_stoic_dir/options.json"
  attach_error_summary=""

  # Detect device architecture and select appropriate .so file
  device_arch="$(getprop ro.product.cpu.abi)"
  case "$device_arch" in
    arm64-v8a)
      stoic_so_path="$stoic_device_sync_dir/stoic/arm64-v8a/stoic-jvmti-agent.so"
      ;;
    x86_64)
      stoic_so_path="$stoic_device_sync_dir/stoic/x86_64/stoic-jvmti-agent.so"
      ;;
    *)
      >&2 echo "Unsupported architecture: $device_arch"
      >&2 echo "Supported architectures: arm64-v8a, x86_64"
      exit 1
      ;;
  esac
  >&2 echo "Using architecture: $device_arch"

  # TODO: Use a lock to ensure that multiple processes aren't attempting to bring
  # the server up simultaneously

  >&2 echo "cleaning $pkg_stoic_dir"
  if ! run_as_compat "$pkg" rm -rf "$pkg_stoic_dir"; then
    # In case there are leftover files from a previous attach using jvmti_root
    "$script_dir/su-run-as" "$pkg" rm -rf "$pkg_stoic_dir"
  fi

  run_as_compat "$pkg" mkdir "$pkg_stoic_dir"
  cross_uid_cp 444 "$stoic_so_path" "$pkg_so"
  cross_uid_cp 444 "$stoic_device_sync_dir/stoic/stoic-jvmti-attach.apk" "$pkg_server_apk"
  echo "{\"stoicProtocolVersion\":$stoic_protocol_version, \"attachedVia\":\"$attach_option\"}" | cross_uid_cp 444 - "$pkg_options_json"

  first_pid="$(pidof "$pkg" || true)"

  # Sets pkg_pid and restarts pkg if needed
  resolve_package_pid "$pkg"

  if [ "$pkg_pid" = "$first_pid" ]; then
    # Since pkg was already running, double-check /proc/pid/maps for stoic-jvmti-agent.so
    if run_as_compat "$pkg" cat /proc/$pkg_pid/maps | grep "stoic-jvmti-agent.so"; then
      >&2 echo "stoic already loaded - need to restart the process first"
      >&2 echo "consider:"
      >&2 echo "  stoic --restart ..."
      exit 1
    fi
  fi

  logcat -T 1 --pid "$pkg_pid" "stoic:v *:w" >&2 &
  logcat_pid=$!

  # setsid runs sh in a new session. This way we can kill the entire process group.
  # We echo the PID of the process group leader, and then read the first line
  # output and capture that as selinux_denials_pid
  # `--line-buffered` is needed because grep defaults to non-line-buffered mode
  # when stdout is not a tty.
  selinux_denials="$pkg_stoic_dir/selinux_denials"
  selinux_denials_pgid_file="$pkg_stoic_dir/selinux_denials_pgid"
  run_as_compat "$pkg" setsid sh -c "printf \"%s\n\" \$\$ > $selinux_denials_pgid_file && logcat -T 1 | grep --line-buffered -E \"avc: denied .*stoic.*permissive=0\" >$selinux_denials" &

  # Sometimes attach-agent complains that the process doesn't exist - maybe
  # because it was created to recently? Sleeping fixes it.
  attach_agent_compat "$pkg" "$pkg_so=$pkg_stoic_dir" || attach_agent_exit_code=$?
  if [ "${attach_agent_exit_code:-0}" -ne 0 ]; then
    >&2 echo "attach-agent exited with code=$attach_agent_exit_code"
    >&2 echo "Attach agent failed... sleeping 1 second and retrying..."
    sleep 1
    attach_agent_compat "$pkg" "$pkg_so=$pkg_stoic_dir"
  fi

  # Poll for server-up file or process exit
  >&2 echo "Waiting for server to come up..."
  start_time=$(date +%s)
  timeout=20
  while :; do
    # Check if server is up
    if run_as_compat "$pkg" sh -c "[ -f $pkg_stoic_dir/server-up ]"; then
      >&2 echo "Server is up!"
      exit 0
    fi

    # Check for SELinux denials
    if run_as_compat "$pkg" sh -c "[ -s $selinux_denials ]"; then
      attach_error_summary="SELinux problem detected - you may be able to work around it with \`adb shell su 0 setenforce 0\`"
      exit 1
    fi

    # Check if target process exited
    if ! ps -p "$pkg_pid" -o NAME= 2>/dev/null | grep -q "$pkg"; then
      target_process_exited=1
      attach_error_summary="Target process ($pkg_pid) exited"
      exit 1
    fi

    # Check for timeout
    current_time=$(date +%s)
    elapsed=$((current_time - start_time))
    if [ "$elapsed" -ge "$timeout" ]; then
      attach_error_summary="Timed out waiting for server to start"
      exit 1
    fi

    sleep 0.1
  done
}

attach_sdk() {
  # TODO: query receivers to verify there is one


  # If the app was just installed or manually stopped via 'am force-stop' then
  # we'll need to unstop it in order for the broadcast to work.
  # (unstop was added in Android 15, so this might fail)
  pm unstop "$pkg" || true

  first_pid="$(pidof "$pkg" || true)"

  # Sets pkg_pid and restarts pkg if needed
  resolve_package_pid "$pkg"

  am broadcast -a com.squareup.stoic.android.sdk.ACTION_UDS_LISTEN -p "$pkg"

  # TODO: wait for confirmation the socket is up
}

# The protocol version the server should expect
stoic_protocol_version="$1"

# The package we'll attach to
pkg="$2"

# One of restart/start_if_needed/do_not_start
start_option="$3"

# TODO: no longer used
debug_option="$4"

# One of jvmti/jvmti_root/sdk
attach_option="$5"

# Check if we need to install/update a demo app
demo_apk=""
case "$pkg" in
  com.squareup.stoic.demoapp.withoutsdk)
    demo_apk="$stoic_device_sync_dir/apk/stoic-demo-app-without-sdk-debug.apk"
    ;;
  com.squareup.stoic.demoapp.withsdk)
    demo_apk="$stoic_device_sync_dir/apk/stoic-demo-app-with-sdk-release.apk"
    ;;
esac

if [ -n "$demo_apk" ]; then
  # This is a demo app - check if it needs to be installed or updated
  apk_timestamp_file="$stoic_device_sync_dir/.installed_apk_timestamps/$pkg"
  apk_mtime=$(stat -c %Y "$demo_apk" 2>/dev/null || echo "0")

  needs_install=false
  if ! pm list packages "$pkg" | grep -x "package:$pkg"; then
    # Package not installed
    needs_install=true
  elif [ ! -f "$apk_timestamp_file" ]; then
    # No timestamp recorded - reinstall to be safe
    needs_install=true
  else
    # Check if APK is newer than what we installed
    installed_mtime=$(cat "$apk_timestamp_file")
    if [ "$apk_mtime" -gt "$installed_mtime" ]; then
      needs_install=true
    fi
  fi

  if [ "$needs_install" = "true" ]; then
    # Try to install with -r flag first - if that fails, uninstall and retry
    if ! pm install -r "$demo_apk" 2>&1; then
      # Fall-back to uninstall and retry (e.g. if signature changed)
      pm uninstall "$pkg"
      pm install "$demo_apk"
      mkdir -p "$(dirname "$apk_timestamp_file")"
      echo "$apk_mtime" > "$apk_timestamp_file"
    else
      # Install succeeded
      mkdir -p "$(dirname "$apk_timestamp_file")"
      echo "$apk_mtime" > "$apk_timestamp_file"
    fi
  fi
elif ! pm list packages "$pkg" | grep -x "package:$pkg"; then
  # Not a demo app and package not found
  attach_error_summary="$pkg not found"
  exit 1
fi

case "$attach_option" in
  jvmti)
    attach_jvmti
    ;;
  jvmti_root)
    # Exactly the same as jvmti, except that run-as-compat uses su-run-as
    # instead of run-as.
    attach_jvmti
    ;;
  sdk)
    attach_sdk
    ;;
  *)
    attach_error_summary="Invalid attach option '$attach_option'"
    exit 1
    ;;
esac
